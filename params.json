{"name":"FormalSystems","tagline":"A Python implementation of Douglas Hofstadter formal systems","body":"FormalSystems\r\n=============\r\n\r\nThis is a Python implementation of *Douglas Hofstadter* formal systems, from his book *GÃ¶del, Escher, Bach: An Eternal Golden Braid* (commonly *GEB*).\r\n\r\nIn fact, you may define your *own formal systems* using a quite simple syntax, close to free text. Examples for *MIU*, *pg*, *fg* and *NDP* formal systems from the book are implemented in directory *definitions*.\r\n\r\nA main Python script gives you possibilities to play with the formal system, including:\r\n\r\n-   axiom schema support (iteration, decision procedure)\r\n-   theorem step by step generation (using different algorithms)\r\n-   theorem derivation\r\n\r\nFormal system definition\r\n------------------------\r\n\r\n### Examples\r\n\r\nThe *MIU* system may be define with:\r\n\r\n> axioms:  \r\n> -   MI\r\n>\r\n> rules:  \r\n> -   x is .\\*, xI =\\> xIU\r\n> -   x is .\\*, Mx =\\> Mxx\r\n> -   x is .*, y is .*, xIIIy =\\> xUy\r\n> -   x y .\\* , xUUy =\\> xy\r\n\r\nThe underlying syntax is YAML (see raw format). You can define one or several axioms, or even an infinite number of axioms using a schema, as in the *pg* formal system:\r\n\r\n> axioms:  \r\n> -   x is -+, xp-gx-\r\n>\r\n> rules:  \r\n> -   x y z are -+, xpygz =\\> xpy-gz-\r\n\r\n### Syntax\r\n\r\nAxiom definitions should be formatted like this (`[]` means this is optional):\r\n\r\n```bash\r\n[def_1, [def_2, ...]] expr\r\n```\r\n\r\nWhere:\r\n\r\n-   `def_i` is an optional definition of *wildcard*, using a regular expression, for example:\r\n\r\n    -   \".\\*\" may be anything including the empty string\r\n    -   \"-+\" is a string composed of \"-\"\r\n\r\nThe definitions are written using `char [is] regexp` or `char1 char2 [are] regexp` if different wildcards have the same definition. Note that you should use only *one character* for wildcard definition.\r\n\r\n-   `expr` is the axiom expression\r\n\r\nRules for theorem production should be formatted like this:\r\n\r\n```bash\r\n[def_1, [def_2, ...]] cond_1 [and cond_2 [and ...]] => th_1 [and th_2 [and ...]]\r\n```\r\n\r\nWhere:\r\n\r\n-   `def_i` is the same as before\r\n-   `cond_i` is a required theorem, in order to produce new theorems (separated by *and* if several conditions)\r\n-   `th_i` is a produced theorems with the rule\r\n\r\nInstallation\r\n------------\r\n\r\nInstall with:\r\n\r\n```bash\r\n$ python setup.py install --user\r\n```\r\n\r\nA script should be put in `~/.local/bin`, make sure this path is in your `$PATH`:\r\n\r\n```bash\r\n$ export PATH=$PATH:~/.local/bin\r\n```\r\n\r\nTests\r\n-----\r\n\r\nIf installation is successful, run the tests with:\r\n\r\n```bash\r\n$ cd tests\r\n$ python test_formalsystems.py -v\r\n```\r\n\r\nMain script\r\n-----------\r\n\r\nAfter installation, you should have the main script `FormalSystemsMain.py` deployed somewhere where you `$PATH` points to, under the name `FormalSystems`. If it is not the case, you can always execute the script directly, assuming the dependencies are properly installed (just *pyyaml* and *LEPL*).\r\n\r\nUsage of the main script is fully documented in `--help` argument.\r\n\r\nYou may generate theorems step by step if the number of axioms is finite:\r\n\r\n```bash\r\n$ FormalSystems definitions/MIU.yaml --iteration 3 \r\n> Finite number of axioms, using step algorithm\r\n\r\nSTEP 1: MI\r\n\r\nP  (1) x is .*, xI => xIU                    for  MI                         gives  MIU\r\nP  (2) x is .*, Mx => Mxx                    for  MI                         gives  MII\r\n.  (3) x is .*, y is .*, xIIIy => xUy        for  MI                       \r\n.  (4) x y  .* , xUUy => xy                  for  MI                       \r\n\r\nSTEP 2: MIU/MII\r\n\r\nP  (1) x is .*, xI => xIU                    for  MII                        gives  MIIU\r\n.  (1) x is .*, xI => xIU                    for  MIU                      \r\nP  (2) x is .*, Mx => Mxx                    for  MII                        gives  MIIII\r\nP  (2) x is .*, Mx => Mxx                    for  MIU                        gives  MIUIU\r\n.  (3) x is .*, y is .*, xIIIy => xUy        for  MII                      \r\n.  (3) x is .*, y is .*, xIIIy => xUy        for  MIU                      \r\n.  (4) x y  .* , xUUy => xy                  for  MII                      \r\n.  (4) x y  .* , xUUy => xy                  for  MIU                      \r\n\r\nSTEP 3: MIIU/MIIII/MIUIU\r\n```\r\n\r\nOr using a bucket where axioms are thrown and theorems computed iteratively if the number of axioms is infinite:\r\n\r\n```bash\r\n$ FormalSystems definitions/pg.yaml --iteration 4\r\n> Infinite number of axioms, using bucket algorithm\r\n\r\n[Adding -p-g-- to bucket]\r\n\r\n=== BUCKET 1: -p-g--\r\n\r\nP  (1) x y z are -+, xpygz => xpy-gz-        for  -p-g--                     gives  -p--g---\r\n[Adding --p-g--- to bucket]\r\n\r\n=== BUCKET 2: -p--g---/--p-g---\r\n\r\nP  (1) x y z are -+, xpygz => xpy-gz-        for  -p--g---                   gives  -p---g----\r\nP  (1) x y z are -+, xpygz => xpy-gz-        for  --p-g---                   gives  --p--g----\r\n[Adding ---p-g---- to bucket]\r\n\r\n=== BUCKET 3: -p---g----/--p--g----/---p-g----\r\n\r\nP  (1) x y z are -+, xpygz => xpy-gz-        for  -p---g----                 gives  -p----g-----\r\nP  (1) x y z are -+, xpygz => xpy-gz-        for  ---p-g----                 gives  ---p--g-----\r\nP  (1) x y z are -+, xpygz => xpy-gz-        for  --p--g----                 gives  --p---g-----\r\n[Adding ----p-g----- to bucket]\r\n\r\n=== BUCKET 4: -p----g-----/---p--g-----/--p---g-----/----p-g-----\r\n```\r\n\r\nOptions are available to display theorem derivation as well:\r\n\r\n```bash\r\n$ FormalSystems definitions/NDP.yaml --quiet --derivation P-----\r\n> Infinite number of axioms, using bucket algorithm\r\n> Rule with several parents, using recursivity\r\n\r\n=== BUCKET 1: --NDP-\r\n=== BUCKET 2: --NDP---/-SD--/P--\r\n=== BUCKET 3: --NDP-----/---SD--/---NDP--\r\n=== BUCKET 4: --NDP-------/---NDP-----/-----SD--/P---/---NDP-\r\n=== BUCKET 5: --NDP---------/---NDP--------/---NDP----/-------SD--/-----SD---/-SD---/----NDP---\r\n=== BUCKET 6: ---NDP-----------/----NDP-------/---NDP-------/--NDP-----------/---------SD--/----NDP-\r\n=== BUCKET 7: ----NDP-----------/----NDP-----/---NDP----------/---NDP--------------/--NDP-------------/-----------SD--/-------SD---/-SD----/----NDP--\r\n=== BUCKET 8: ----NDP---------/----NDP---------------/---NDP-------------/---NDP-----------------/--NDP---------------/----NDP------/-------------SD--/-------SD----/-----SD----/-----------SD---/-----NDP-\r\n=== BUCKET 9: --NDP-----------------/-----NDP------/----NDP-------------/---NDP--------------------/---NDP----------------/----NDP----------/----NDP-------------------/---------------SD--/-SD-----/-------------SD---/-----------SD----/P-----/-----NDP--\r\n\r\n=== Theorem P----- found, derivation:\r\n[1 ]  Axiom                                                                     gives  --NDP-              \r\n[2 ]  (1) x y are -+, xNDPy => xNDPxy           for  --NDP-                     gives  --NDP---            \r\n[3 ]  Axiom                                                                     gives  ---NDP--            \r\n[3 ]  (1) x y are -+, xNDPy => xNDPxy           for  --NDP---                   gives  --NDP-----          \r\n[4 ]  Axiom                                                                     gives  ----NDP-            \r\n[4 ]  (1) x y are -+, xNDPy => xNDPxy           for  ---NDP--                   gives  ---NDP-----         \r\n[4 ]  (2) z is -+, --NDPz => zSD--              for  --NDP-----                 gives  -----SD--           \r\n[5 ]  (1) x y are -+, xNDPy => xNDPxy           for  ----NDP-                   gives  ----NDP-----        \r\n[5 ]  (3) x z are -+, zSDx and x-NDPz => zSDx-  for  -----SD-- and ---NDP-----  gives  -----SD---          \r\n[6 ]  (3) x z are -+, zSDx and x-NDPz => zSDx-  for  -----SD--- and ----NDP-----  gives  -----SD----         \r\n[7 ]  (4) z is -+, z-SDz => Pz-                 for  -----SD----                gives  P-----\r\n```\r\n\r\nPython API\r\n----------\r\n\r\nSome tests using *doctests*:\r\n\r\n```python\r\n>>> from formalsystems.formalsystems import FormalSystem, Theorem\r\n```\r\n\r\nMIU formal system:\r\n\r\n```python\r\n>>> fs = FormalSystem()\r\n>>> fs.read_formal_system('../definitions/MIU.yaml')\r\n>>> r = fs.apply_rules_step(fs.iterate_over_schema(), step=4, verbose=False)\r\nSTEP 1: MI\r\nSTEP 2: MIU/MII\r\nSTEP 3: MIIU/MIIII/MIUIU\r\nSTEP 4: MIIIIU/MIIIIIIII/MIIUIIU/MIUIUIUIU/MIU/MUI\r\n>>> print [str(a) for a in fs.iterate_over_schema()]\r\n['MI']\r\n```\r\n\r\npg formal system:\r\n\r\n```python\r\n>>> fs = FormalSystem()\r\n>>> fs.read_formal_system('../definitions/pg.yaml')\r\n>>> r = fs.apply_rules_bucket_till(fs.iterate_over_schema(), max_turns=4, verbose=False)\r\n=== BUCKET 1: -p-g--\r\n=== BUCKET 2: -p--g---/--p-g---\r\n=== BUCKET 3: -p---g----/--p--g----/---p-g----\r\n=== BUCKET 4: -p----g-----/---p--g-----/--p---g-----/----p-g-----\r\n>>> r = fs.apply_rules_bucket_till(fs.iterate_over_schema(), min_len=9, verbose=False)\r\n=== BUCKET 1: -p-g--\r\n=== BUCKET 2: -p--g---/--p-g---\r\n=== BUCKET 3: -p---g----/--p--g----/---p-g----\r\n```\r\n\r\nNDP formal system:\r\n\r\n```python\r\n>>> fs = FormalSystem()\r\n>>> fs.read_formal_system('../definitions/NDP.yaml')\r\n>>> r = fs.apply_rules_bucket_till(fs.iterate_over_schema(), max_turns=2, full=True, verbose=False)\r\n=== BUCKET 1: --NDP-\r\n=== BUCKET 2: --NDP---/-SD--/P--\r\n```\r\n\r\nSuccessful derivation:\r\n\r\n```python\r\n>>> fs = FormalSystem()\r\n>>> fs.read_formal_system('../definitions/NDP.yaml')\r\n>>> r = fs.derivation_asc(fs.iterate_over_schema(), Theorem('P-----'), full=True, max_turns=10)\r\n<BLANKLINE>\r\n...\r\n=== Theorem P----- found, derivation:\r\n...\r\n```\r\n\r\nFailed derivation:\r\n\r\n```python\r\n>>> fs = FormalSystem()\r\n>>> fs.read_formal_system('../definitions/MIU.yaml')\r\n>>> r = fs.derivation_step(fs.iterate_over_schema(), Theorem('MIUIU'), step=5)\r\n<BLANKLINE>\r\n...\r\n=== Theorem MIUIU found, derivation:\r\n...\r\n>>> r = fs.derivation_step(fs.iterate_over_schema(), Theorem('MU'), step=5)\r\n<BLANKLINE>\r\n...\r\n=== Theorem MU not found\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}